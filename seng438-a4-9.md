**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#4 – Mutation Testing and Web app testing**

| Group \#:      |   9  |
| Bryant Stevens |
| Student Names: |     |
| Noureldin Amer |
| Thevin Mahawatte |
| Saman Pordanesh |

# Introduction
In this report, we will discuss mutation testing on 10 mutants of the Range class's getLength method. We will start with a brief overview of the test suite used and the results of the tests performed. Then, I will provide an analysis of each mutant, explaining how the test suite handled them. We will also discuss the effectiveness of the test suite, the impact of equivalent mutants on mutation score accuracy, and how we could improve the mutation score of the test suites.

Finally, we will explain the Selenium test case design process, which includes two test cases for the login functionality of an Amazon account. Furthermore, we will examine the advantages and disadvantages of mutation testing.

# Analysis of 10 Mutants of the Range class 
Original code:
 ``` java
 public double getLength() {
 return this.upper - this.lower;
 }
 ```

 Test suits:
 ``` java
   @Test //
     public void getLengthTest() {
         assertEquals("The expected length between lower-bound and upper-bound is 5",5,exampleRange.getLength(), .000000001d);
     }
     @Test //
     public void getLengthShouldBeZeroTest() {
         Range newRange = new Range(0,0);
         assertEquals("The expected length between lower-bound and upper-bound is 5", 0, newRange.getLength(), .000000001d);
     }
     @Test
     public void getLengthShouldBeFiveTest() {
         assertEquals("The central value of -2 and 3 should be 5",5, exampleRange.getLength(), .000000001d);
     }
 ```

 Mutations test results on : 
 1. replaced double return with 0.0d for org/jfree/data/Range::getLength →
 KILLED
 2. replaced return of double value with -(x + 1) for
 org/jfree/data/Range::getLength → KILLED
 3. Negated double field upper → KILLED
 4. Negated double field lower → KILLED
 5. Replaced double operation with first member → KILLED
 6. Replaced double operation by second member → KILLED
 7. Replaced double subtraction with addition → KILLED
 8. Replaced double subtraction with multiplication → KILLED
 9. Replaced double subtraction with division → KILLED
 10. Replaced double subtraction with modulus → KILLED


 Based on the test results, it seems that all 10 mutants generated by PIT for the getLength method have been killed by our test suite. This indicates that our test suite is effectively testing the getLength method, as it is able to catch all the introduced faults (mutations).

 Here's an analysis of each mutant:

 1. Replaced double return with 0.0d: Our test suite killed this mutant since you have test cases that expect non-zero length values, such as getLengthTest and getLengthShouldBeFiveTest.
 2. Replaced return of double value with -(x + 1): Our test suite killed this mutant because you have test cases that check for specific lengths, such as getLengthTest, getLengthShouldBeZeroTest, and getLengthShouldBeFiveTest.
 3. Negated double field upper: Our test suite killed this mutant since you have test cases that expect specific lengths based on the range, such as getLengthTest, getLengthShouldBeZeroTest, and getLengthShouldBeFiveTest.
 4. Negated double field lower: Similar to the previous mutant, our test suite killed this mutant due to the presence of test cases that expect specific lengths based on the range.
 5. Replaced double operation with the first member: Our test suite killed this mutant as you have test cases that check for specific lengths, which would fail if the operation was replaced with the first member.
 6. Replaced double operation with the second member: Similar to the previous mutant, our test suite killed this mutant because of the presence of test cases that check for specific lengths.
 7. Replaced double subtraction with addition: Our test suite killed this mutant due to test cases that expect specific lengths based on the range, such as getLengthTest, getLengthShouldBeZeroTest, and getLengthShouldBeFiveTest.
 8. Replaced double subtraction with multiplication: Our test suite killed this mutant as you have test cases that check for specific lengths based on the range.
 9. Replaced double subtraction with division: Our test suite killed this mutant due to the presence of test cases that check for specific lengths based on the range.
 10. Replaced double subtraction with modulus: Our test suite killed this mutant because you have test cases that expect specific lengths based on the range.


 In conclusion, our test suite effectively tests the getLength method, as demonstrated by its ability to kill all 10 mutants generated by PIT. This indicates that our test suite is robust and can catch introduced faults in the getLength method.
# Report all the statistics and the mutation score for each test class


![Screenshot (3)](https://user-images.githubusercontent.com/99352026/226074562-d81c32f3-f0e3-42e6-bdf8-f8d91e6280c7.png)

![Screenshot (6)](https://user-images.githubusercontent.com/99352026/226074617-9988e962-32c6-4256-8d46-8db62521710d.png)

![Screenshot (4)](https://user-images.githubusercontent.com/99352026/226074608-218e6197-535a-4e54-80dc-9f3c1e6357c1.png)

![Screenshot (5)](https://user-images.githubusercontent.com/99352026/226074595-b2ab4251-c25f-4af0-bf04-fe17936c52ec.png)


# Analysis drawn on the effectiveness of each of the test classes

# A discussion on the effect of equivalent mutants on mutation score accuracy

Equivalent mutants pose a challenge in mutation testing, as they can negatively impact the accuracy of the mutation score. Equivalent mutants are changes in the code that do not alter the program's behavior, so they cannot be detected by any test suite, even a perfect one.

The presence of equivalent mutants can lead to an underestimation of the mutation score, making it seem like the test suite is less effective at catching faults than it truly is. Detecting equivalent mutants is difficult due to the undecidability of the problem.

Some techniques to identify and reduce the impact of equivalent mutants include code analysis and simplification, compiler optimizations, manual inspection, automated approaches like constraint-based analysis and symbolic execution, and machine learning. However, these techniques have limitations and may not be applicable to all cases.


# A discussion of what could have been done to improve the mutation score of the test suites
An initial run of mutatiom testing indicated a score of 56%. To increase, the code we increased the code coverage. Additionally, To improve the mutation score, it is crucial to use diverse test data that can explore different execution paths and uncover hidden faults.

# Why do we need mutation testing? Advantages and disadvantages of mutation testing
## Advantages of mutation testing
- Thoroughness
- Quality assurance
- Improves test coverage
- Helps in debugging

## Disadvantages of mutation testing
- Computational complexity
- Requires expertise
- False positives
- Difficult to automate

# Explain your SELENUIM test case design process

Login - Valid : The functionality of this test case is to login to your amazon account with a valid username and password. First the sign in page is prompted and you enter the username and press continue button. After that you are directed to the password field where you enter the correct password and once you press submit it should sign into your account.

Login - Invalid Username : The functionality of this test case is to login to your amazon account but with an invalid username and a valid password. First the sign in page is prompted and you enter the invalid username and press continue button. It will provide you an error message mentioning that no such account exist and once you enter the correct username it will direct you to the password field where you enter the correct password and once you press submit it should sign into your account.

Login - Invalid Password : The functionality of this test case is to login to your amazon account with a valid username but with an invalid password. First the sign in page is prompted and you enter the username and press continue button. After that you are directed to the password field where you enter the invalid password and it will show you that it is the wrong password. And when you enter the correct password in the correct time, and you press submit it should sign into your account.

Add new address : The functionality of this test case is to add a new address to your signed in account. Once you are signed in and when you go to the add new address page, it as to enter street number, name, city, postal code and the country. After valid input of data, it will add the new address to your account.
Sign out : The functionality of this test case is to sign out from your signed in account. When you press the sign out button in the main page, it will automatically sign you out of the account.

Search Bar : The functionality of this test case is to search an item in the search bar. When you go to the search bar and press search icon, you should be able to see the list of products that belongs to the searching name that you gave.

Change Language : The functionality of this test case is to change the language of the operating page. According to the location we are in, Canada, we have between two languages to pick, select English or French where I changed to both languages after each other.
Sort price from high to low : The functionality of this test case is to sort the product list from price high to low. When you go to the sorting options, you can check the sort by price high to low options.


# Explain the use of assertions and checkpoints

Assertions and checkpoints were used throughout our test cases to ensure the test conditions, as well as validate the outcomes of each test. We use commands such as assert text or verify title to establish certain requirements of our SUT in order to pass the current test.

# how did you test each functionaity with different test data

# Discuss advantages and disadvantages of Selenium vs. Sikulix
## Advantages of Selenium
- Supports a variety of programming languages, including Java, Python, C#, and JavaScript.
- Supports multiple browsers, including Chrome, Firefox, Internet Explorer, and Safari.
- Provides a wide range of testing capabilities, including UI testing, functional testing, and regression testing.
- Supports distributed testing, which enables parallel execution of tests across multiple machines.
- Has a large and active community, which provides support and contributes to the development of the tool.

## Disadvantages of Selenium
- Requires expertise in programming and testing, which can make it difficult for non-technical team members to use.
- Can be time-consuming to set up and configure, especially for complex applications.
- Can be prone to flakiness due to timing issues and synchronization problems.
- Limited support for testing desktop applications and mobile apps.

## Advantages of SikuliX
- Provides a visual testing approach, which makes it easy to use for non-technical team members.
- Supports testing of desktop applications and web applications.
- Has built-in image recognition capabilities, which enables it to interact with applications regardless of the underlying technology used.
- Supports multiple operating systems, including Windows, Linux, and Mac OS.
- Has a scripting interface that supports multiple programming languages.

## Disadvantages of SikuliX
- Can be slower compared to other testing tools due to its image recognition capabilities.
- Can be less reliable than other testing tools due to the potential for false positives and false negatives.
- Limited support for testing mobile apps.
- Smaller community compared to Selenium, which can make it more challenging to find support and resources.
# How the team work/effort was divided and managed
The workload was divided equally amongst the 4 members. Thevin and Noureldin worked together to increase the mutation testing for the datautilities 

# Difficulties encountered, challenges overcome, and lessons learned
A few challenges were encountered in this project. One major difficulty was coordinating our schedules. To solve this issue, we made a plan to hold regular checkups throught the two week period of the assignment, along with one in-person meeting to divide the work. We also faced some technical difficulties with the testing framework, which required us to spend some extra time researching and finding solutions.
# Comments/feedback on the lab itself
Overall, getting mutation testing through PIT in eclipce was a struggle, and took us the majority of the lab duration to get PIT to work. However, GUI testing was an easier task, and provided ensight into real a new type of testing.


