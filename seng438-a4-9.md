**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#4 – Mutation Testing and Web app testing**

| Group \#:      |     |
| -------------- | --- |
| Student Names: |     |
| Noureldin Amer               |     |
|                |     |
|                |     |

# Introduction


# Analysis of 10 Mutants of the Range class 


Original code:
``` java
public double getLength() {
return this.upper - this.lower;
}
```

Test suits:
``` java
  @Test //
    public void getLengthTest() {
        assertEquals("The expected length between lower-bound and upper-bound is 5",5,exampleRange.getLength(), .000000001d);
    }

    @Test //
    public void getLengthShouldBeZeroTest() {
        Range newRange = new Range(0,0);
        assertEquals("The expected length between lower-bound and upper-bound is 5", 0, newRange.getLength(), .000000001d);
    }

    @Test
    public void getLengthShouldBeFiveTest() {
        assertEquals("The central value of -2 and 3 should be 5",5, exampleRange.getLength(), .000000001d);
    }
```

Mutations test results on : 
1. replaced double return with 0.0d for org/jfree/data/Range::getLength →
KILLED
2. replaced return of double value with -(x + 1) for
org/jfree/data/Range::getLength → KILLED
3. Negated double field upper → KILLED
4. Negated double field lower → KILLED
5. Replaced double operation with first member → KILLED
6. Replaced double operation by second member → KILLED
7. Replaced double subtraction with addition → KILLED
8. Replaced double subtraction with multiplication → KILLED
9. Replaced double subtraction with division → KILLED
10. Replaced double subtraction with modulus → KILLED


Based on the test results, it seems that all 10 mutants generated by PIT for the getLength method have been killed by our test suite. This indicates that our test suite is effectively testing the getLength method, as it is able to catch all the introduced faults (mutations).

Here's an analysis of each mutant:

1. Replaced double return with 0.0d: Our test suite killed this mutant since you have test cases that expect non-zero length values, such as getLengthTest and getLengthShouldBeFiveTest.
2. Replaced return of double value with -(x + 1): Our test suite killed this mutant because you have test cases that check for specific lengths, such as getLengthTest, getLengthShouldBeZeroTest, and getLengthShouldBeFiveTest.
3. Negated double field upper: Our test suite killed this mutant since you have test cases that expect specific lengths based on the range, such as getLengthTest, getLengthShouldBeZeroTest, and getLengthShouldBeFiveTest.
4. Negated double field lower: Similar to the previous mutant, our test suite killed this mutant due to the presence of test cases that expect specific lengths based on the range.
5. Replaced double operation with the first member: Our test suite killed this mutant as you have test cases that check for specific lengths, which would fail if the operation was replaced with the first member.
6. Replaced double operation with the second member: Similar to the previous mutant, our test suite killed this mutant because of the presence of test cases that check for specific lengths.
7. Replaced double subtraction with addition: Our test suite killed this mutant due to test cases that expect specific lengths based on the range, such as getLengthTest, getLengthShouldBeZeroTest, and getLengthShouldBeFiveTest.
8. Replaced double subtraction with multiplication: Our test suite killed this mutant as you have test cases that check for specific lengths based on the range.
9. Replaced double subtraction with division: Our test suite killed this mutant due to the presence of test cases that check for specific lengths based on the range.
10. Replaced double subtraction with modulus: Our test suite killed this mutant because you have test cases that expect specific lengths based on the range.


In conclusion, our test suite effectively tests the getLength method, as demonstrated by its ability to kill all 10 mutants generated by PIT. This indicates that our test suite is robust and can catch introduced faults in the getLength method.

# Report all the statistics and the mutation score for each test class



# Analysis drawn on the effectiveness of each of the test classes

# A discussion on the effect of equivalent mutants on mutation score accuracy

# A discussion of what could have been done to improve the mutation score of the test suites
An initial run of mutatiom testing indicated a score of 56%. To increase, the code we increased the code coverage. Additionally, To improve the mutation score, it is crucial to use diverse test data that can explore different execution paths and uncover hidden faults.

# Why do we need mutation testing? Advantages and disadvantages of mutation testing
## Advantages of mutation testing
- Thoroughness
- Quality assurance
- Improves test coverage
- Helps in debugging

## Disadvantages of mutation testing
- Computational complexity
- Requires expertise
- False positives
- Difficult to automate
# Explain your SELENUIM test case design process

# Explain the use of assertions and checkpoints

# how did you test each functionaity with different test data

# Discuss advantages and disadvantages of Selenium vs. Sikulix
## Advantages of Selenium
- Supports a variety of programming languages, including Java, Python, C#, and JavaScript.
- Supports multiple browsers, including Chrome, Firefox, Internet Explorer, and Safari.
- Provides a wide range of testing capabilities, including UI testing, functional testing, and regression testing.
- Supports distributed testing, which enables parallel execution of tests across multiple machines.
- Has a large and active community, which provides support and contributes to the development of the tool.

## Disadvantages of Selenium
- Requires expertise in programming and testing, which can make it difficult for non-technical team members to use.
- Can be time-consuming to set up and configure, especially for complex applications.
- Can be prone to flakiness due to timing issues and synchronization problems.
- Limited support for testing desktop applications and mobile apps.

## Advantages of SikuliX
- Provides a visual testing approach, which makes it easy to use for non-technical team members.
- Supports testing of desktop applications and web applications.
- Has built-in image recognition capabilities, which enables it to interact with applications regardless of the underlying technology used.
- Supports multiple operating systems, including Windows, Linux, and Mac OS.
- Has a scripting interface that supports multiple programming languages.

## Disadvantages of SikuliX
- Can be slower compared to other testing tools due to its image recognition capabilities.
- Can be less reliable than other testing tools due to the potential for false positives and false negatives.
- Limited support for testing mobile apps.
- Smaller community compared to Selenium, which can make it more challenging to find support and resources.
# How the team work/effort was divided and managed


# Difficulties encountered, challenges overcome, and lessons learned
A few challenges were encountered in this project. One major difficulty was coordinating our schedules. To solve this issue, we made a plan to hold regular checkups throught the two week period of the assignment, along with one in-person meeting to divide the work. We also faced some technical difficulties with the testing framework, which required us to spend some extra time researching and finding solutions.
# Comments/feedback on the lab itself



