**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#4 – Mutation Testing and Web app testing**

| Group \#:      |   9  |
| Bryant Stevens |
| Student Names: |     |
| Noureldin Amer |
| Thevin Mahawatte |
| Saman Pordanesh |

# Introduction
In this report, we will discuss mutation testing on 10 mutants of the Range class's getLength method. We will start with a brief overview of the test suite used and the results of the tests performed. Then, I will provide an analysis of each mutant, explaining how the test suite handled them. We will also discuss the effectiveness of the test suite, the impact of equivalent mutants on mutation score accuracy, and how we could improve the mutation score of the test suites.

Finally, we will explain the Selenium test case design process, which includes two test cases for the login functionality of an Amazon account. Furthermore, we will examine the advantages and disadvantages of mutation testing.

# Analysis of 10 Mutants of the Range class 
Original code:
 ``` java
 public double getLength() {
 return this.upper - this.lower;
 }
 ```

 Test suits:
 ``` java
   @Test //
     public void getLengthTest() {
         assertEquals("The expected length between lower-bound and upper-bound is 5",5,exampleRange.getLength(), .000000001d);
     }
     @Test //
     public void getLengthShouldBeZeroTest() {
         Range newRange = new Range(0,0);
         assertEquals("The expected length between lower-bound and upper-bound is 5", 0, newRange.getLength(), .000000001d);
     }
     @Test
     public void getLengthShouldBeFiveTest() {
         assertEquals("The central value of -2 and 3 should be 5",5, exampleRange.getLength(), .000000001d);
     }
 ```

 Mutations test results on : 
 1. replaced double return with 0.0d for org/jfree/data/Range::getLength →
 KILLED
 2. replaced return of double value with -(x + 1) for
 org/jfree/data/Range::getLength → KILLED
 3. Negated double field upper → KILLED
 4. Negated double field lower → KILLED
 5. Replaced double operation with first member → KILLED
 6. Replaced double operation by second member → KILLED
 7. Replaced double subtraction with addition → KILLED
 8. Replaced double subtraction with multiplication → KILLED
 9. Replaced double subtraction with division → KILLED
 10. Replaced double subtraction with modulus → KILLED


 Based on the test results, it seems that all 10 mutants generated by PIT for the getLength method have been killed by our test suite. This indicates that our test suite is effectively testing the getLength method, as it is able to catch all the introduced faults (mutations).

 Here's an analysis of each mutant:

 1. Replaced double return with 0.0d: Our test suite killed this mutant since you have test cases that expect non-zero length values, such as getLengthTest and getLengthShouldBeFiveTest.
 2. Replaced return of double value with -(x + 1): Our test suite killed this mutant because you have test cases that check for specific lengths, such as getLengthTest, getLengthShouldBeZeroTest, and getLengthShouldBeFiveTest.
 3. Negated double field upper: Our test suite killed this mutant since you have test cases that expect specific lengths based on the range, such as getLengthTest, getLengthShouldBeZeroTest, and getLengthShouldBeFiveTest.
 4. Negated double field lower: Similar to the previous mutant, our test suite killed this mutant due to the presence of test cases that expect specific lengths based on the range.
 5. Replaced double operation with the first member: Our test suite killed this mutant as you have test cases that check for specific lengths, which would fail if the operation was replaced with the first member.
 6. Replaced double operation with the second member: Similar to the previous mutant, our test suite killed this mutant because of the presence of test cases that check for specific lengths.
 7. Replaced double subtraction with addition: Our test suite killed this mutant due to test cases that expect specific lengths based on the range, such as getLengthTest, getLengthShouldBeZeroTest, and getLengthShouldBeFiveTest.
 8. Replaced double subtraction with multiplication: Our test suite killed this mutant as you have test cases that check for specific lengths based on the range.
 9. Replaced double subtraction with division: Our test suite killed this mutant due to the presence of test cases that check for specific lengths based on the range.
 10. Replaced double subtraction with modulus: Our test suite killed this mutant because you have test cases that expect specific lengths based on the range.


 In conclusion, our test suite effectively tests the getLength method, as demonstrated by its ability to kill all 10 mutants generated by PIT. This indicates that our test suite is robust and can catch introduced faults in the getLength method.
# Report all the statistics and the mutation score for each test class


![Screenshot (3)](https://user-images.githubusercontent.com/99352026/226074562-d81c32f3-f0e3-42e6-bdf8-f8d91e6280c7.png)

![Screenshot (6)](https://user-images.githubusercontent.com/99352026/226074617-9988e962-32c6-4256-8d46-8db62521710d.png)

![Screenshot (4)](https://user-images.githubusercontent.com/99352026/226074608-218e6197-535a-4e54-80dc-9f3c1e6357c1.png)

![Screenshot (5)](https://user-images.githubusercontent.com/99352026/226074595-b2ab4251-c25f-4af0-bf04-fe17936c52ec.png)

Exmaple of strategy that we used to increase mutant coverage:

The mutants in question are:

Incremented (a++) double local variable number 1 → SURVIVED

Decremented (a--) double local variable number 1 → SURVIVED

These mutants involve incrementing and decrementing the lower variable (local variable number 1) within the constructor itself. To create test cases that increase mutation coverage for these specific mutants, you need to focus on the boundaries where the lower and upper values are very close to each other.

``` java
@Test
public void testIncrementedLower() {
    double lower = 2.9999999;
    double upper = 3.0;
    Range incrementedLowerRange = new Range(lower, upper);
    assertEquals("The lower bound value of incremented lower should be the same as original lower", lower, incrementedLowerRange.getLowerBound(), 0.000000001d);
}

@Test
public void testDecrementedLower() {
    double lower = 3.0;
    double upper = 3.0;
    Range decrementedLowerRange = new Range(lower, upper);
    assertEquals("The lower bound value of decremented lower should be the same as original lower", lower, decrementedLowerRange.getLowerBound(), 0.000000001d);
}

```

These test cases have been designed to be sensitive to the specific mutants in question. The first test case, testIncrementedLower, creates a Range object with lower and upper values very close to each other. If the mutation increments the lower variable within the constructor, the lower value will become greater than the upper value, and the constructor will throw an IllegalArgumentException. By asserting that the lower value of the constructed object is equal to the original lower value, the test case will fail if the mutation is present, killing the mutant.

The second test case, testDecrementedLower, creates a Range object with lower and upper values equal to each other. If the mutation decrements the lower variable within the constructor, the lower value will become less than the upper value, and the constructor will not throw an IllegalArgumentException. By asserting that the lower value of the constructed object is equal to the original lower value, the test case will fail if the mutation is present, killing the mutant.

By adding these test cases to your test suite, you can improve its ability to kill the surviving mutants and increase the mutation coverage.


# Analysis drawn on the effectiveness of each of the test classes

# A discussion on the effect of equivalent mutants on mutation score accuracy

Equivalent mutants pose a challenge in mutation testing, as they can negatively impact the accuracy of the mutation score. Equivalent mutants are changes in the code that do not alter the program's behavior, so they cannot be detected by any test suite, even a perfect one.

The presence of equivalent mutants can lead to an underestimation of the mutation score, making it seem like the test suite is less effective at catching faults than it truly is. Detecting equivalent mutants is difficult due to the undecidability of the problem.

Some techniques to identify and reduce the impact of equivalent mutants include code analysis and simplification, compiler optimizations, manual inspection, automated approaches like constraint-based analysis and symbolic execution, and machine learning. However, these techniques have limitations and may not be applicable to all cases.


# A discussion of what could have been done to improve the mutation score of the test suites

- Test edge cases: Create test cases that specifically target edge cases, such as empty inputs, maximum or minimum values, or unusual data types, as they often reveal potential issues.

- Test different inputs: Use a diverse range of inputs to cover various possible execution paths, which can help kill mutants that only appear under specific input conditions.

- Test error and exception handling: Design test cases that verify the correct handling of errors and exceptions, ensuring the expected behavior is maintained even in the presence of mutants.

- Test with a focus on code coverage: Strive for high code coverage by creating test cases that cover as many lines of code and branches as possible, increasing the likelihood of detecting and killing mutants.

- Review surviving mutants: Analyze the mutants that survive your test suite and identify gaps in test coverage. Create or modify test cases to target these specific mutants, which will help increase the mutation score.

By focusing on these strategies and refining your test suite accordingly, you can improve its ability to detect and kill mutants, thus increasing the mutation score and ensuring the reliability of your code.

# Why do we need mutation testing? Advantages and disadvantages of mutation testing

- Test suite effectiveness: Mutation testing evaluates the ability of a test suite to detect faults, ensuring the reliability of the code.

- Identify test coverage gaps: It highlights areas of code that lack sufficient testing, promoting more comprehensive test coverage and increased confidence.

- Better test design: Encourages developers to create more effective test cases by exposing weaknesses in the test suite, which results in improved code quality.

- Eliminate redundant tests: Mutation testing can reveal unnecessary test cases, allowing developers to maintain a more efficient test suite.

- Improve code maintainability: Ensures that code changes are effectively tested, making the codebase easier to understand and modify over time.

- Boost confidence in code correctness: A higher mutation score indicates the test suite's effectiveness, increasing confidence in the codebase and reducing the risk of defects.

In summary, mutation testing is crucial for assessing the test suite's quality and effectiveness, leading to better test coverage, code quality, and maintainability. It helps developers create better test cases and fosters greater confidence in the code's correctness.

## Advantages of mutation testing
- Thoroughness
- Quality assurance
- Improves test coverage
- Helps in debugging

## Disadvantages of mutation testing
- Computational complexity
- Requires expertise
- False positives
- Difficult to automate

# Explain your SELENUIM test case design process

Login - Valid : The functionality of this test case is to login to your amazon account with a valid username and password. First the sign in page is prompted and you enter the username and press continue button. After that you are directed to the password field where you enter the correct password and once you press submit it should sign into your account.

Login - Invalid Username : The functionality of this test case is to login to your amazon account but with an invalid username and a valid password. First the sign in page is prompted and you enter the invalid username and press continue button. It will provide you an error message mentioning that no such account exist and once you enter the correct username it will direct you to the password field where you enter the correct password and once you press submit it should sign into your account.

Login - Invalid Password : The functionality of this test case is to login to your amazon account with a valid username but with an invalid password. First the sign in page is prompted and you enter the username and press continue button. After that you are directed to the password field where you enter the invalid password and it will show you that it is the wrong password. And when you enter the correct password in the correct time, and you press submit it should sign into your account.

Add new address : The functionality of this test case is to add a new address to your signed in account. Once you are signed in and when you go to the add new address page, it as to enter street number, name, city, postal code and the country. After valid input of data, it will add the new address to your account.
Sign out : The functionality of this test case is to sign out from your signed in account. When you press the sign out button in the main page, it will automatically sign you out of the account.

Search Bar : The functionality of this test case is to search an item in the search bar. When you go to the search bar and press search icon, you should be able to see the list of products that belongs to the searching name that you gave.

Change Language : The functionality of this test case is to change the language of the operating page. According to the location we are in, Canada, we have between two languages to pick, select English or French where I changed to both languages after each other.
Sort price from high to low : The functionality of this test case is to sort the product list from price high to low. When you go to the sorting options, you can check the sort by price high to low options.


# Explain the use of assertions and checkpoints

Assertions and checkpoints were used throughout our test cases to ensure the test conditions, as well as validate the outcomes of each test. We use commands such as assert text or verify title to establish certain requirements of our SUT in order to pass the current test.

# how did you test each functionaity with different test data

# Discuss advantages and disadvantages of Selenium vs. Sikulix

Selenium:

Advantages: cross-platform compatibility, wide range of programming languages, support for multiple browsers, active community support
Disadvantages: difficulty in automating non-web applications, requires knowledge of programming, limited support for image-based testing
SikuliX:

Advantages: easy to use, image-based testing, cross-platform compatibility, support for non-web applications
Disadvantages: limited programming language support, limited browser support, requires some image editing skills

In general, if you're testing web applications and have programming knowledge, Selenium is a good choice. However, if you need to test non-web applications or have limited programming knowledge, SikuliX is a better option.

## Advantages of Selenium
- Supports a variety of programming languages, including Java, Python, C#, and JavaScript.
- Supports multiple browsers, including Chrome, Firefox, Internet Explorer, and Safari.
- Provides a wide range of testing capabilities, including UI testing, functional testing, and regression testing.
- Supports distributed testing, which enables parallel execution of tests across multiple machines.
- Has a large and active community, which provides support and contributes to the development of the tool.

## Disadvantages of Selenium
- Requires expertise in programming and testing, which can make it difficult for non-technical team members to use.
- Can be time-consuming to set up and configure, especially for complex applications.
- Can be prone to flakiness due to timing issues and synchronization problems.
- Limited support for testing desktop applications and mobile apps.

## Advantages of SikuliX
- Provides a visual testing approach, which makes it easy to use for non-technical team members.
- Supports testing of desktop applications and web applications.
- Has built-in image recognition capabilities, which enables it to interact with applications regardless of the underlying technology used.
- Supports multiple operating systems, including Windows, Linux, and Mac OS.
- Has a scripting interface that supports multiple programming languages.

## Disadvantages of SikuliX
- Can be slower compared to other testing tools due to its image recognition capabilities.
- Can be less reliable than other testing tools due to the potential for false positives and false negatives.
- Limited support for testing mobile apps.
- Smaller community compared to Selenium, which can make it more challenging to find support and resources.
# How the team work/effort was divided and managed
The workload was divided equally amongst the 4 members. Thevin and Noureldin worked together to increase the mutation testing for the datautilities 

# Difficulties encountered, challenges overcome, and lessons learned
A few challenges were encountered in this project. One major difficulty was coordinating our schedules. To solve this issue, we made a plan to hold regular checkups throught the two week period of the assignment, along with one in-person meeting to divide the work. We also faced some technical difficulties with the testing framework, which required us to spend some extra time researching and finding solutions.
# Comments/feedback on the lab itself
Overall, getting mutation testing through PIT in eclipce was a struggle, and took us the majority of the lab duration to get PIT to work. However, GUI testing was an easier task, and provided ensight into real a new type of testing.


